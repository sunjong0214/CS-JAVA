# mystudy

# 컴파일
```
javac -d build/classes/java/main(목적폴더-컴파일한 파일을 둘 곳) src/main/java/com/eomcs/*.java(소스 위치)
```
-다른 클래스를 사용하는 소스파일을 컴파일 할때\
목적 폴더 명령어와 소스 위치 명령어 사이에 -cp build/classes/java/main 를 넣어준다

# 실행
```
java -cp(classpath) build/classes/java/main(cp는 패키지가 있는 목적디렉토리까지만) com.eomcs.E1(class 파일 위치, 실행할 떄 반드시 패키지 명을 지정)
```
# 패키지명
com.* or org.* 등등 도메인 명이다. ex)com.facebook com.microsoft 등 개발자나 회사 간 이름 충돌 방지\
역순으로 되어있는 이유는 상위에서 하위로 분류해 쉽게\
다른 패키지에 있는 클래스 불러올시 패키지명 작성 필요 ex)com.eomcs.F1 v1;

# 패키지명 작성 관례
com.도메인.제품명.역할명 순으로 작성

# 패키지 멤버 클래스(패키지 클래스) - 패키지에 소속된 클래스

# public 클래스
공개 클래스 소스파일을 찾기 쉽도록 하기 위해 반드시 소스파일명과 일치해야한다

# main() 메소드
프로그램 entry point (입구)

# classpath (cp)
.class파일의 위치를 알려주는 명령어

# javadoc html 문서 만들기
```
javadoc -encoding UTF-8 -charset UTF-8 -d javadoc -sourcepath src/main/java/ com.eomcs.lang.ex02\
```
javadoc 디렉토리가 만들어지고 index.html 파일에 들아가면 열람가능\
코드 위에 \
```
/**
 * 클래스에 대한 설명
 * @author eomjinyoung
 *
 */
public class Exam0200 {}
```
이런식으로 작성하면 해당 코드에 대한 설명으로 출력된다\
javadoc 나오기 전 소스 코드를 바꾸면 문서도 수정해야하는데 개발자들이 귀찮아서 수정하지 않는 것이 현실 ->\
javadoc으로 소스와 문서를 결합하고 문서 생성을 자동화해 해결

# @Annotation 애노테이션 주석
컴파일과 실행할 때 사용, 다른 문서를 생성할 때 사용

# gradle 프로젝트 생성방법
프로젝트 디렉토리 생성 후 해당 폴더에서 gradle init\
application - java - groovy 선택 나머지는 디폴트\
소스 패키지 com.eomcs\
build.gradle 수정\
-plugin 수정,자바 소스 옵션,프로젝트 이름 수정\
gradle eclipse 명령어 실행 - 이클립스 파일 생성\
import - general - existing~~ 로 임포트\
plugin에서 application을 수정한 경우 application task를 지워준다 지우지 않으면 gradle eclipse 오류뜸

# 램
램에 숫자를 저장할 때는 이진수로 변환 후 저장 그때 사용하는 방식이 2의 보수를 사용

# 2의 보수
1의 보수의 문제를 해결하기 위해 나옴\
1의 보수인 경우 2진법으로 변환 후 계산 했을 떄 원하는 값보다 1이 작은 결과가 출력\
그래서 1번째 방법 - 미리 음수에 1을 더하는 방식으로 해결\
2번쨰 - 오른쪽에서부터 1을 찾고 첫번째로 찾은 1을 제외한 나머지를 반대 값으로 바꿈\
3번째 - *\
이 방법으로 1의 음수에는 존재하던 음수 0 값이 사라짐 , 음수 0이 사라짐으로 인해 -128까지 가능\
다양한 데이터들의 범위가 양수보다 음수가 한자리 더 큰 이유 (int, long 등)

# 비트 크기와 저장할 수 있는 값의 범위
8bit = -128 ~ 127\
16bit = -32768 ~ 32767\
32bit = -21억 ~ 21억\
64bit =  -약922경 ~ 922경\
메모리 기본 단위 = 8bit(1byte)\
크기 분류\
8bit(1byte) = byte\
16bit(2byte) = short\
32bit(4byte) = int\
64bit(1byte) = long\
자바에서 int와 long 을 알아보는 방법은 정수 뒤에 L을 붙임

# 부동소수점(float)
소수점 아래 있는 수를 2진수로 변환하는 방법은 값에 2를 곱한 후 소숫 점 위에 값을 차레로 넣어준다.\
ex) 0.375 의 경우\
0.375 * 2 = 0.75 -> 0\
0.75 * 2 = 1.5 -> 1\
0.5 * 2 = 1.0 -> 1\
그래서 0.375의 2진수 변환 값은 0.011 이 된다

# 부동소수점 표기법
3.14\
=31.4 * 10의 -1 승 = 31.4E-1\
=314 * 10의 -2 승 = 314E-2\
=0.314 * 10의 1 승 = 0.314E1\
=0.0314 * 10의 2 승 = 0.314E2

# 정규화 후 부동소수점을 32bit로 2진수로 표현
12.375를 이진수로 변환하면\
1100.011 -정규화-> 1.100011*2의 3승\
**정규화란**\
소수점의 위치를 조정하여 가수부와 지수부로 분리\
-왼쪽 1만 남기고 모두 소수점 아래로 보낸다.\
-남은 1은 무조건 1이기떄문에 날린다\
**결론**\
-0.100011 * 2의3승\
정규화한 위 값의 소숫점 아래 수 100011을 가수부 영역에 저장한다.\
지수부에는 위의 값에서 2의 3승을 2진수로 표현한다. 위에 값에서는 3승이니\
3+(bias) 공식을 따름 -> 3+(2의 (8-1)승 - 1) -> 3+(128-1) -> 130이 나온다\
위의 나온 130을 이진수로 변환한 값은\
1000 0010이 나온다 이걸 지수부에 저장\
[0]    [10000010]      [100011 나머지는 0]\
부호     지수부       가수부(유효숫자를 뜻)\
1비트   8비트             23비트\
-> 0100 0001 0100 0110 0000 0000 0000 0000\
16진수로\
-> 0x41460000\
이 가공된 값이 RAM이나 HDD에 저장된다\
이때 소수점 아래의 값이 클수록 가수부의 길이도 길어지는데 그 값이 선언한 파라미터인 float이나 double의 자리수를 넘어선다면 뒷부분은 짤리게 된다.(191줄 참조)\
이때 5가지 정책으로 짤린 부분을 처리한다\
**부동 소수점의 반올림 모드 5가지**\
-짝수로 반올림 (round to nearest, ties to even)\
-큰 절대값으로 반올림 (round to nearest, ties away from zero)\
-올림 (round toward +∞)\
-버림 (round toward -∞)\
-절삭 (round toward zero)\
참고 - https://devocean.sk.com/blog/techBoardDetail.do?ID=165270

# 2진수와 16진수
10진수의 0~15를 2진수로\
->0000 0001 0010 0011 ~~\
10진수의 0~15를 16진수로\
->0123456789abcdef\
2진수 4bit를 16진수의 1자리로 변환가능\
2진수를 간결하게 표기할 수 있고 변환이 용이해 16진수를 많이 사용

# 캐리지 리턴, 라인 피드
윈도우 상에선 줄바꿈 할 때 2byte가 삽입(unix = \n(1byte))\
\r\n 으로 표기됨 \
\n = cr 캐리지 리턴이며 맨 앞으로 이동하라는 뜻\
\n = lf 라인피드 new line을 뜻함


# [Character set] 
문자를 2진수로 변환하는 규칙(문자집합)

## 1. ASCII
7bit\
영어만을 위한 문자\
다른 언어 지원이 필요해 나온 것이 ANSI

## 2. ISO-8859-1
8bit = ASCII + 유럽문자

## 3. EUR-KR
16bit = ISO-8859-1 + 한글\
한글문자에 대한 코드 정의\
똠 등 정의가 되어있지 않은 글자가 있음\
그런 글자들은 또 + ㅁ 으로 처리함\
코드 상으로 B7C7 A4B1으로 처리

## 조합형(아래한글)
한글(1) + 초성(5) + 중성(5) + 종성(5) 총 16bit로 처리\
각각 32자로 한글의 모든 조합 처리가능\
국제 표준 X

## 4. MS949
EUC-KR + 나머지 한글(지원 안되던) = 11172자 지원 (16bit)\
EUC-KR에 지원 안되던 글자들은 새로운 코드(8C63)로 적용해 EUC-KR로 만든 문서들에 영향이 안 가도록 함\
그 때문에 코드의 숫자 순으로 정렬했을 떄 코드의 순서가 한글의 순서와 맞지않아 정렬이 안됨(가 보다 똠 같은 코드를 새로 적용한 글자가 더 위에서 정렬됨)\
국제 표준 X (다른 OS에서 못 읽음)

## 5. unicode(UTF-16 BE)
2~4byte(언어마다 바뀜)
A -> 0x0041 = 2byte 사용 -> 1바이트로 충분함에도 불구하고 2바이트 사용으로 메모리가 낭비 -> 이걸 보완하기 위해 UTF-8이 등장\
EUC-KR 과 다르게 코드를 새로 정의해 코드 순서대로 정렬 가능\
Java는 문자를 다룰 때 unicode(UTF-16 BE) 사용\
참조 - https://lordofkangs.tistory.com/86

### LE    vs     BE
가 : 00AC         AC00\
A : 4100         0041\
바이트 위치가 반대

## 6. UTF-8
unicode를 번형한 것이 UTF-8\
unicode의 4바이트 중 3바이트까지만 씀(거의)\
A : 0x0041 -> 0x41\
![UTF-*](https://i.namu.wiki/i/Y-wwe3c7QJncyki3U-wkQfKxW3zAeXQB_58PJJULR3S4tXqb1L3n928QIANcDkQOmwZ14ufJz5Qiz8xRbLEdffRBpwghohU6B6-1s3AY-9IY-zrJ4Ch08cG97zoUA_WY9Sll6a0o2Ofv5e9EEqYjVQ.webp)

# [리터널]
## 정수
32bit = 4byte = int = 0x00000000;\
64bit = 8byte = long = 0x0000000000000000;

## 문자
char = 2byte = 0~65535 유니코드(UTF-16)

## 부동소수점 주의할 점 (소수점 출력할 떄 자리수를 정확히 처리해줘야하는 이유)
유효자릿수가 넘어가는 경우 에러가 아니라 값이 잘리거나 변형이 된 값이 저장된다\
float(4byte = 7자리)에 7자리 넘는 부동소수점 값을 넣으면 안됨\
또 부동소수점은 100프로가 아님, 조금 다른 값이 출력될 수 있음\
그렇기 때문에 부동소수점을 활용할 땐 필요한 자리수를 정확히 계산해서 그만큼만 출력해야한다\
그래서 보통 **<u>float = 6자리 double = 15자리**</u>까지는 오차없이 출력 가능하기 떄문에 조심할 것

## 자바에서 유니코드 쓰는 경우
파이 기호, 한자, 시그마 기호 등 직접 적기 힘든 부분은 유니코드를 사용해서 작성\
\\u 뒤에 코드를 작성 
```
sysout(\u03c0) = π ;
```
## 폰트
-Raster 폰트 (bitmap)/
크기를 늘리면 계단 형상 발생/
출력 속도가 빠름
-Vector 폰트 (truetype)/
최근에 많이 사용/
깔끔하게 출력/
속도가 상대적으로 느리지만 cpu의 발전으로 단점이 없어짐

# ANSI 코드
```
System.out.print(\033[1;32m String \033[0m\);
```
위 같은 형식\
1m = bold , 32m = red color, 0m = reset 등등\
이러한 형식으로 사용할 수 있음

# 변수
값을 담을 메모리\
**변수 선언**\
값을 담을 메모리를 준비시키는 명령문 = JVM가 관리하는 메모리 중 메모리 할당(?)\
만들 메모리 종류 = data type(int, string 등)\
메모리 이름 = variable\
```
int(data type) x(varialbe) = 0;
```

# 문자열
메모리에 저장시 크기는 JVM에 따라 다르고 메모리의 주소를 저장한다 = 레퍼런스(reference)\
ABC의경우\
[0041 0042 0043] [글자개수] [문자열에 대한 정보]\
코드(6byte)     3     크기 알 수 없음

# 변수명
1. 일반 변수 -> camel 표기법\
 첫번쨰 알파벳은 소문자, 각 단어의 시작은 대문자
2. 상수(constants)\
상수는 값을 한번만 저장 가능, 대문자로 표기, 단어 사이에 밑줄 삽입 
```
final int PI = 3.14f; 
FIRST_NUMBER = 3; 등
```
# 인스턴스
![인스턴스](https://velog.velcdn.com/images/k7nsuy/post/3e6ad3a8-04c5-444a-af34-3e5dd88443ac/image.png)\
참조) https://velog.io/@k7nsuy/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EB%9E%80

# 레퍼런스
메모리의 주소를 뜻함\
byte, short, int, long, float, double, boolean, char를 제외하고 모두 레퍼런스로 보면 됨

# 가비지(garbage)
주소를 잃어버려 사용하지 못하는 인스턴스

    int[] a = new int[3];
    a = new int[2];

이러한 경우 위에 선언했떤 arr[3] 크기의 배열은 주소값이 덮어씌어져서 사용하지 못함

## 가바지 컬렉터 실행
메모리가 부족해지면 JVM은 OS에 메모리를 추가로 요청하기 전에 가비지 컬렉터를 실행해 가비지를 제거하여 메모리를 확보\
가비지 컬렉터가 실행되기 전에는 가비지는 계속 존재해 메모리 낭비가 발생